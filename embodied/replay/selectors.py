from collections import defaultdict, deque

import numpy as np

from . import sampletree


class Fifo:

  def __init__(self):
    self.queue = deque()

  def __call__(self):
    return self.queue[0]

  def __setitem__(self, key, stepids):
    self.queue.append(key)

  def __delitem__(self, key):
    if self.queue[0] == key:
      self.queue.popleft()
    else:
      # This is very slow but typically not used.
      self.queue.remove(key)


class Uniform:

  def __init__(self, seed=0):
    """Manage a set of keys with uniform random access capabilities.
    It uses a list to maintain the keys and a dictionary to map each key to its index in the list for efficient operations

    Args:
        seed (int, optional): seed for the random number generator, allowing for reproducible results. Defaults to 0.
    """
    self.indices = {}
    self.keys = []
    self.rng = np.random.default_rng(seed)

  def __call__(self):
    index = self.rng.integers(0, len(self.keys)).item()  # generate a random integer between 0 and the number of keys
    return self.keys[index]    # return the key at the uniformly generated index

  def __setitem__(self, key, stepids):
    """add a new key, the key cannot be repeated/already present in the list

    Args:
        key (optional): key to be added
        stepids (_type_): <unused>
    """
    self.indices[key] = len(self.keys)
    self.keys.append(key)

  def __delitem__(self, key):
    """delete a key from the list and the dictionary, if the to be deleted key is not in the last position, it replaces the key with the last key in the list,
    and updates the dictionary accordingly

    Args:
        key (optional): key to be deleted
    """
    index = self.indices.pop(key)
    last = self.keys.pop()
    if index != len(self.keys):
      self.keys[index] = last
      self.indices[last] = index


class Recency:
  """<Auto-generated docstring, no time to read the code thoroughly>
    Initializes a Recency object that maintains items with their insertion steps
    and provides functionality for sampling these items based on their age-related probabilities.
    
    The sampling process weights the probability of selecting each item according to
    its recency, with more recently added items typically having a higher probability of
    selection, as defined by the uprobs array.

    Parameters:
    - uprobs (array-like): A non-increasing array of probabilities corresponding to the
                            recency of each item. The first element should have the highest
                            probability, reflecting the most recent addition.
    - seed (int): Optional; a seed for the random number generator to ensure reproducibility.

    Attributes:
    - self.uprobs (array): Stores the user-provided uprobs array.
    - self.tree (list of ndarray): A probability tree constructed from uprobs to facilitate
                                    efficient sampling.
    - self.rng (Generator): A numpy random number generator initialized with the provided seed.
    - self.step (int): A counter for the total number of items added, serving as unique identifiers.
    - self.steps (dict): Maps item keys to their respective insertion steps.
    - self.items (dict): Maps insertion steps to item keys, allowing for recency-based retrieval.
    """
  def __init__(self, uprobs, seed=0):
    assert uprobs[0] >= uprobs[-1], uprobs
    self.uprobs = uprobs
    self.tree = self._build(uprobs)
    self.rng = np.random.default_rng(seed)
    self.step = 0
    self.steps = {}
    self.items = {}

  def __call__(self):
    for retry in range(10):
      try:
        age = self._sample(self.tree, self.rng)
        if len(self.items) < len(self.uprobs):
          age = int(age / len(self.uprobs) * len(self.items))
        return self.items[self.step - 1 - age]
      except KeyError:
        # Item might have been deleted very recently.
        if retry < 9:
          import time
          time.sleep(0.01)
        else:
          raise

  def __setitem__(self, key, stepids):
    self.steps[key] = self.step
    self.items[self.step] = key
    self.step += 1

  def __delitem__(self, key):
    step = self.steps.pop(key)
    del self.items[step]

  def _sample(self, tree, rng, bfactor=16):
    path = []
    for level, prob in enumerate(tree):
      segment = prob[*path]
      path += (rng.choice(len(segment), p=segment),)
    index = sum(
        index * bfactor ** (len(tree) - level - 1)
        for level, index in enumerate(path))
    return index

  def _build(self, uprobs, bfactor=16):
    assert np.isfinite(uprobs).all(), uprobs
    assert (uprobs >= 0).all(), uprobs
    depth = int(np.ceil(np.log(len(uprobs)) / np.log(bfactor)))
    size = bfactor ** depth
    uprobs = np.concatenate([uprobs, np.zeros(size - len(uprobs))])
    tree = [uprobs]
    for level in reversed(range(depth - 1)):
      tree.insert(0, tree[0].reshape((-1, bfactor)).sum(-1))
    for level, prob in enumerate(tree):
      prob = prob.reshape([bfactor] * (1 + level))
      total = prob.sum(-1, keepdims=True)
      with np.errstate(divide='ignore', invalid='ignore'):
        tree[level] = np.where(total, prob / total, prob)
    return tree


class Prioritized:

  # TODO: Checkpoint priorities.
  """<Auto-generated docstring, no time to read the code thoroughly>
    Manages a collection of items with associated priorities to enable prioritized sampling.
    The priorities influence the probability of each item being sampled, allowing items with
    higher priorities to be sampled more frequently. This can be particularly useful in 
    scenarios such as reinforcement learning where certain experiences are more valuable for
    training than others.

    Parameters:
    - exponent (float): A factor that adjusts the impact of each priority on its sampling probability.
                        When exponent > 1, higher priorities are exaggerated, making them more likely
                        to be sampled. When exponent < 1, the differences between priorities are lessened.
    - initial (float): The initial priority assigned to each new item.
    - zero_on_sample (bool): If True, an item's priority is set to zero upon being sampled.
    - maxfrac (float): The maximum fraction that the highest individual priority can contribute to the
                       aggregate priority calculation. Must be between 0 and 1. If 0, only the mean
                       priority is used. If 1, only the maximum priority is used.
    - branching (int): The branching factor of the underlying sample tree, affecting its structure.
    - seed (int): Seed for the random number generator used in sampling.

    Attributes:
    - tree (SampleTree): A tree structure that supports efficient prioritized sampling.
    - prios (defaultdict): A dictionary mapping from time step identifiers to priorities.
    - stepitems (defaultdict): Maps time step identifiers to the list of keys (items) associated with them.
    - items (dict): Maps keys to their respective time step identifiers.

    Methods:
    - prioritize(stepids, priorities): Updates the priorities of given step identifiers.
    - __call__(): Samples an item based on its priority and potentially zeroes its priority.
    - __setitem__(key, stepids): Adds an item with given step identifiers.
    - __delitem__(key): Removes an item and updates associated data structures.
    - _aggregate(key): Calculates the aggregated priority for a given key, to take these multiple priority scores of the key and compute a single priority value that reflects the overall priority of the key.
    """
  def __init__(
      self, exponent=1.0, initial=1.0, zero_on_sample=False,
      maxfrac=0.0, branching=16, seed=0):
    assert 0 <= maxfrac <= 1, maxfrac
    self.exponent = float(exponent)
    self.initial = float(initial)
    self.zero_on_sample = zero_on_sample
    self.maxfrac = maxfrac
    self.tree = sampletree.SampleTree(branching, seed)
    self.prios = defaultdict(lambda: self.initial)
    self.stepitems = defaultdict(list)
    self.items = {}

  def prioritize(self, stepids, priorities):
    if not isinstance(stepids[0], bytes):
      stepids = [x.tobytes() for x in stepids]
    for stepid, priority in zip(stepids, priorities):
      try:
        self.prios[stepid] = priority
      except KeyError:
        print('Ignoring priority update for removed time step.')
        pass
    items = []
    for stepid in stepids:
      items += self.stepitems[stepid]
    for key in list(set(items)):
      try:
        self.tree.update(key, self._aggregate(key))
      except KeyError:
        print('Ignoring tree update for removed time step.')
        pass

  def __call__(self):
    key = self.tree.sample()
    if self.zero_on_sample:
      zeros = [0.0] * len(self.items[key])
      self.prioritize(self.items[key], zeros)
    return key

  def __setitem__(self, key, stepids):
    if not isinstance(stepids[0], bytes):
      stepids = [x.tobytes() for x in stepids]
    self.items[key] = stepids
    [self.stepitems[stepid].append(key) for stepid in stepids]
    self.tree.insert(key, self._aggregate(key))

  def __delitem__(self, key):
    self.tree.remove(key)
    stepids = self.items.pop(key)
    for stepid in stepids:
      stepitems = self.stepitems[stepid]
      stepitems.remove(key)
      if not stepitems:
        del self.stepitems[stepid]
        del self.prios[stepid]

  def _aggregate(self, key):
    # Both list comprehensions in this function are a performance bottleneck
    # because they are called very often.
    prios = [self.prios[stepid] for stepid in self.items[key]]
    if self.exponent != 1.0:
      prios = [x ** self.exponent for x in prios]
    mean = sum(prios) / len(prios)
    if self.maxfrac:
      return self.maxfrac * max(prios) + (1 - self.maxfrac) * mean
    else:
      return mean


class Mixture:
  """<Auto-generated docstring, no time to read the code thoroughly>
    Manages a mixture of different selectors, each associated with a fraction that
    defines the probability of that selector being chosen to perform an action.
    This class allows for probabilistic delegation of tasks to a collection of 
    selector objects based on specified probabilities.

    Parameters:
    - selectors (dict): A dictionary mapping keys to selector objects. Each selector
                        is capable of performing actions, e.g., sampling or updating priorities.
    - fractions (dict): A dictionary mapping the same keys as `selectors` to probabilities
                        (fractions) that sum to 1. These probabilities determine how likely
                        it is that a corresponding selector will be chosen to handle an action.
    - seed (int): Seed for the random number generator, ensuring reproducible outcomes.

    Attributes:
    - selectors (list): A sorted list of selectors based on the keys, filtered to exclude
                        selectors associated with a zero fraction.
    - fractions (np.array): An array of probabilities associated with each selector in
                            the sorted `selectors` list, used for random selection.
    - rng (np.random.default_rng): A random number generator instance initialized with the provided seed.

    Methods:
    - __call__(): Randomly selects one of the selectors based on the fractions and delegates
                  the call to the selected selector.
    - __setitem__(key, stepids): Passes the setitem operation to all selectors, allowing
                                each to handle the key and stepids as necessary.
    - __delitem__(key): Removes the specified key from all selectors.
    - prioritize(stepids, priorities): Delegates prioritization tasks to all selectors
                                       that have a 'prioritize' method.
    """
  def __init__(self, selectors, fractions, seed=0):
    assert set(selectors.keys()) == set(fractions.keys())
    assert sum(fractions.values()) == 1, fractions
    for key, frac in list(fractions.items()):
      if not frac:
        selectors.pop(key)
        fractions.pop(key)
    keys = sorted(selectors.keys())
    self.selectors = [selectors[key] for key in keys]
    self.fractions = np.array([fractions[key] for key in keys], np.float32)
    self.rng = np.random.default_rng(seed)

  def __call__(self):
    return self.rng.choice(self.selectors, p=self.fractions)()

  def __setitem__(self, key, stepids):
    for selector in self.selectors:
      selector[key] = stepids

  def __delitem__(self, key):
    for selector in self.selectors:
      del selector[key]

  def prioritize(self, stepids, priorities):
    for selector in self.selectors:
      if hasattr(selector, 'prioritize'):
        selector.prioritize(stepids, priorities)
